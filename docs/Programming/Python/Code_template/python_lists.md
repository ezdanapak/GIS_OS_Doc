
# თემა: მონაცემთა სიები (List). ოპერაციები სიებზე, მრავალგანზომილებიანი სიები, Tuple მონაცემთა ტიპი

## 1. შესავალი — მონაცემთა სტრუქტურების როლი Python-ში
Python გთავაზობს რამდენიმე ძირითადი მონაცემთა ტიპს: რიცხვები, სტრიქონები, ლოგიკური მნიშვნელობები.  
მონაცემთა ორგანიზებისთვის კი უმნიშვნელოვანესია კონტეინერები—მათ შორის ყველაზე გამოყენებადი არის სიები (Lists) და ტუფლები (Tuples).

მონაცემთა სიები (Lists) არის Python-ის ერთ-ერთი ყველაზე მნიშვნელოვანი და ხშირად გამოყენებადი მონაცემთა სტრუქტურა. სიები საშუალებას გვაძლევს შევინახოთ მრავალი მნიშვნელობა ერთ ცვლადში და ეფექტურად ვიმუშაოთ მონაცემთა კოლექციებზე.
სიების გამოყენებით შეგვიძლია:

შევინახოთ დაკავშირებული მონაცემები ერთად
ვიმუშაოთ დიდი რაოდენობის ინფორმაციაზე
დავაორგანიზოთ და დავაწესრიგოთ მონაცემები
შევქმნათ უფრო რთული მონაცემთა სტრუქტურები


## 2. სიები (List)

### 2.1 სიის შექმნა
```python
numbers = [10, 20, 30]
mixed = [1, "hello", True, 3.14]
empty = []
```

### 2.2 ელემენტებზე წვდომა
```python
numbers = [10, 20, 30]
print(numbers[0])
print(numbers[2])
print(numbers[-1])
```

## 3. ძირითადი ოპერაციები სიებზე

### 3.1 ელემენტის დამატება
```python
lst.append(4)
lst.insert(1, "Python")
a.extend(b)
```

### 3.2 ელემენტის ამოშლა
```python
lst.remove(2)
lst.pop(1)
del lst[1:3]
```

### 3.3 სიების დახარისხება
```python
nums.sort()
nums.sort(reverse=True)
sorted_list = sorted(nums)
```

## 4. მრავალგანზომილებიანი სიები
```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
```

## 5. Tuple მონაცემთა ტიპი
```python
t = (10, 20, 30)
print(t[0])
```

## 6. პრაქტიკული მაგალითები

### მაგალითი 1 — მომხმარებლიდან მიღებული მონაცემების სიის შექმნა
```python
names = []
for i in range(3):
    name = input("შეიყვანე სახელი: ")
    names.append(name)
print(names)
```

### მაგალითი 2 — max/min/average
```python
nums = [10, 20, 5, 40]
print(max(nums), min(nums), sum(nums)/len(nums))
```

### მაგალითი 3 — Matrix ბეჭდვა
```python
for row in matrix:
    print("სტრიქონი:", row)
```


1. სიის შექმნა
1.1 ცარიელი სიის შექმნა
python# ცარიელი სიის შექმნა კვადრატული ფრჩხილებით
my_list = []

# ცარიელი სიის შექმნა list() ფუნქციით
my_list2 = list()

print(my_list)   # []
print(my_list2)  # []
1.2 მნიშვნელობებით სიის შექმნა
python# რიცხვების სია
numbers = [1, 2, 3, 4, 5]

# სტრიქონების სია
fruits = ["ვაშლი", "მსხალი", "ბანანი", "ატამი"]

# შერეული ტიპების სია
mixed_list = [1, "ტექსტი", 3.14, True, None]

# სია სიაში (ჩადგმული სია)
nested_list = [1, 2, [3, 4, 5], 6]

print(numbers)      # [1, 2, 3, 4, 5]
print(fruits)       # ['ვაშლი', 'მსხალი', 'ბანანი', 'ატამი']
print(mixed_list)   # [1, 'ტექსტი', 3.14, True, None]
1.3 სიის შექმნა range() ფუნქციით
python# 0-დან 9-მდე რიცხვების სია
numbers = list(range(10))
print(numbers)  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 1-დან 10-მდე რიცხვების სია
numbers2 = list(range(1, 11))
print(numbers2)  # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# ყოველი მეორე რიცხვი 0-დან 20-მდე
even_numbers = list(range(0, 21, 2))
print(even_numbers)  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
2. სიის ელემენტებზე წვდომა (Indexing)
pythonfruits = ["ვაშლი", "მსხალი", "ბანანი", "ატამი", "საზამთრო"]

# პირველი ელემენტი (ინდექსი 0)
print(fruits[0])   # ვაშლი

# მესამე ელემენტი (ინდექსი 2)
print(fruits[2])   # ბანანი

# ბოლო ელემენტი (უარყოფითი ინდექსი)
print(fruits[-1])  # საზამთრო

# ბოლოდან მეორე
print(fruits[-2])  # ატამი

# სიის სიგრძე
print(len(fruits))  # 5
2.1 Slicing (სიის ნაწილის ამოღება)
pythonnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# პირველი 3 ელემენტი
print(numbers[0:3])   # [0, 1, 2]

# ინდექსიდან 2 ინდექსამდე 7
print(numbers[2:7])   # [2, 3, 4, 5, 6]

# ინდექსიდან 5 ბოლომდე
print(numbers[5:])    # [5, 6, 7, 8, 9]

# დასაწყისიდან ინდექსამდე 4
print(numbers[:4])    # [0, 1, 2, 3]

# ყოველი მეორე ელემენტი
print(numbers[::2])   # [0, 2, 4, 6, 8]

# სიის შებრუნება
print(numbers[::-1])  # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
3. ელემენტის დამატება
3.1 append() - ბოლოში დამატება
pythonfruits = ["ვაშლი", "მსხალი"]
print("თავდაპირველი სია:", fruits)

fruits.append("ბანანი")
print("append-ის შემდეგ:", fruits)

fruits.append("ატამი")
print("კიდევ append:", fruits)
# შედეგი: ['ვაშლი', 'მსხალი', 'ბანანი', 'ატამი']
3.2 insert() - კონკრეტულ ადგილას დამატება
pythonfruits = ["ვაშლი", "ბანანი", "ატამი"]
print("თავდაპირველი:", fruits)

# ინდექსზე 1 ჩასმა
fruits.insert(1, "მსხალი")
print("insert-ის შემდეგ:", fruits)
# შედეგი: ['ვაშლი', 'მსხალი', 'ბანანი', 'ატამი']

# დასაწყისში ჩასმა
fruits.insert(0, "საზამთრო")
print("დასაწყისში:", fruits)
# შედეგი: ['საზამთრო', 'ვაშლი', 'მსხალი', 'ბანანი', 'ატამი']
3.3 extend() - სხვა სიის დამატება
pythonlist1 = [1, 2, 3]
list2 = [4, 5, 6]

print("თავდაპირველი list1:", list1)

list1.extend(list2)
print("extend-ის შემდეგ:", list1)
# შედეგი: [1, 2, 3, 4, 5, 6]

# შედარება: append vs extend
list3 = [1, 2, 3]
list4 = [1, 2, 3]

list3.append([4, 5])
list4.extend([4, 5])

print("append:", list3)  # [1, 2, 3, [4, 5]]
print("extend:", list4)  # [1, 2, 3, 4, 5]
4. ელემენტის წაშლა/ამოშლა
4.1 remove() - მნიშვნელობით წაშლა
pythonfruits = ["ვაშლი", "მსხალი", "ბანანი", "ატამი", "მსხალი"]

fruits.remove("მსხალი")  # პირველი "მსხალი" წაიშლება
print(fruits)  # ['ვაშლი', 'ბანანი', 'ატამი', 'მსხალი']

# თუ ელემენტი არ არსებობს, მოხდება შეცდომა
try:
    fruits.remove("ყურძენი")
except ValueError:
    print("ელემენტი არ მოიძებნა სიაში!")
4.2 pop() - ინდექსით წაშლა და დაბრუნება
pythonnumbers = [10, 20, 30, 40, 50]

# ბოლო ელემენტის ამოშლა
last = numbers.pop()
print("ამოშლილი:", last)      # 50
print("დარჩენილი სია:", numbers)  # [10, 20, 30, 40]

# კონკრეტული ინდექსის ამოშლა
second = numbers.pop(1)
print("ამოშლილი:", second)     # 20
print("დარჩენილი სია:", numbers)  # [10, 30, 40]
4.3 del - ელემენტის ან სიის წაშლა
pythonfruits = ["ვაშლი", "მსხალი", "ბანანი", "ატამი", "საზამთრო"]

# კონკრეტული ელემენტის წაშლა
del fruits[2]
print(fruits)  # ['ვაშლი', 'მსხალი', 'ატამი', 'საზამთრო']

# რამდენიმე ელემენტის წაშლა (slice)
del fruits[1:3]
print(fruits)  # ['ვაშლი', 'საზამთრო']

# მთელი სიის წაშლა
del fruits
# print(fruits)  # შეცდომა: ცვლადი აღარ არსებობს
4.4 clear() - სიის გასუფთავება
pythonnumbers = [1, 2, 3, 4, 5]
numbers.clear()
print(numbers)  # []
5. სიის დახარისხება (Sorting)
5.1 sort() - სიის დახარისხება (ადგილზე)
python# რიცხვების დახარისხება
numbers = [5, 2, 8, 1, 9, 3]
numbers.sort()
print("ზრდადობით:", numbers)  # [1, 2, 3, 5, 8, 9]

numbers.sort(reverse=True)
print("კლებადობით:", numbers)  # [9, 8, 5, 3, 2, 1]

# სტრიქონების დახარისხება
fruits = ["ბანანი", "ვაშლი", "მსხალი", "ატამი"]
fruits.sort()
print("ანბანის მიხედვით:", fruits)
# ['ატამი', 'ბანანი', 'ვაშლი', 'მსხალი']

# სიგრძის მიხედვით დახარისხება
words = ["ბანანი", "ვაშლი", "მსხალი", "კივი"]
words.sort(key=len)
print("სიგრძით:", words)  # ['კივი', 'ვაშლი', 'ბანანი', 'მსხალი']
5.2 sorted() - ახალი დახარისხებული სიის შექმნა
pythonnumbers = [5, 2, 8, 1, 9, 3]

# ორიგინალი არ იცვლება
sorted_numbers = sorted(numbers)
print("ორიგინალი:", numbers)       # [5, 2, 8, 1, 9, 3]
print("დახარისხებული:", sorted_numbers)  # [1, 2, 3, 5, 8, 9]

# კლებადობით
sorted_desc = sorted(numbers, reverse=True)
print("კლებადობით:", sorted_desc)  # [9, 8, 5, 3, 2, 1]
5.3 reverse() - სიის შებრუნება
pythonnumbers = [1, 2, 3, 4, 5]
numbers.reverse()
print(numbers)  # [5, 4, 3, 2, 1]

# ალტერნატივა - slicing
numbers2 = [1, 2, 3, 4, 5]
reversed_numbers = numbers2[::-1]
print(reversed_numbers)  # [5, 4, 3, 2, 1]
6. სიაში ძებნა და რაოდენობა
6.1 in ოპერატორი - ელემენტის არსებობის შემოწმება
pythonfruits = ["ვაშლი", "მსხალი", "ბანანი", "ატამი"]

if "ბანანი" in fruits:
    print("ბანანი არის სიაში")

if "ყურძენი" not in fruits:
    print("ყურძენი არ არის სიაში")
6.2 index() - ელემენტის ინდექსის პოვნა
pythonfruits = ["ვაშლი", "მსხალი", "ბანანი", "ატამი", "მსხალი"]

# პირველი "მსხალი"-ს ინდექსი
position = fruits.index("მსხალი")
print(position)  # 1

# დიაპაზონში ძებნა
position2 = fruits.index("მსხალი", 2)  # ინდექსიდან 2 დაწყება
print(position2)  # 4

# თუ ელემენტი არ არსებობს
try:
    position = fruits.index("ყურძენი")
except ValueError:
    print("ელემენტი არ მოიძებნა!")
6.3 count() - ელემენტის რაოდენობა
pythonnumbers = [1, 2, 3, 2, 4, 2, 5, 2]

count_2 = numbers.count(2)
print("2-ის რაოდენობა:", count_2)  # 4

count_6 = numbers.count(6)
print("6-ის რაოდენობა:", count_6)  # 0
7. სიებზე სხვა ოპერაციები
7.1 სიების შეერთება
pythonlist1 = [1, 2, 3]
list2 = [4, 5, 6]

# + ოპერატორით
combined = list1 + list2
print(combined)  # [1, 2, 3, 4, 5, 6]

# * ოპერატორით (გამრავლება)
repeated = list1 * 3
print(repeated)  # [1, 2, 3, 1, 2, 3, 1, 2, 3]
7.2 სიის კოპირება
pythonoriginal = [1, 2, 3, 4, 5]

# არასწორი - reference კოპირება
copy1 = original
copy1[0] = 999
print("ორიგინალი:", original)  # [999, 2, 3, 4, 5] - შეიცვალა!

# სწორი - ახალი სიის შექმნა
original = [1, 2, 3, 4, 5]
copy2 = original.copy()
# ან copy2 = original[:]
copy2[0] = 999
print("ორიგინალი:", original)  # [1, 2, 3, 4, 5] - არ შეიცვალა
print("ასლი:", copy2)  # [999, 2, 3, 4, 5]
8. მრავალგანზომილებიანი სიები
8.1 ორგანზომილებიანი სია (მატრიცა)
python# 3x3 მატრიცა
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# ელემენტებზე წვდომა
print(matrix[0][0])  # 1 (პირველი რიგი, პირველი სვეტი)
print(matrix[1][2])  # 6 (მეორე რიგი, მესამე სვეტი)
print(matrix[2][1])  # 8 (მესამე რიგი, მეორე სვეტი)

# რიგების გადარჩევა
print(matrix[0])     # [1, 2, 3] - პირველი რიგი
print(matrix[1])     # [4, 5, 6] - მეორე რიგი
8.2 მატრიცაზე იტერაცია
pythonmatrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# ყველა ელემენტის დაბეჭდვა
for row in matrix:
    for element in row:
        print(element, end=" ")
    print()  # ახალი ხაზი

# ინდექსებით
for i in range(len(matrix)):
    for j in range(len(matrix[i])):
        print(f"matrix[{i}][{j}] = {matrix[i][j]}")
8.3 პრაქტიკული მაგალითი - სტუდენტების ქულები
python# სტუდენტების ქულები 3 გამოცდაზე
grades = [
    [85, 90, 88],  # სტუდენტი 1
    [92, 87, 95],  # სტუდენტი 2
    [78, 85, 80]   # სტუდენტი 3
]

# თითოეული სტუდენტის საშუალო ქულა
for i, student_grades in enumerate(grades, 1):
    average = sum(student_grades) / len(student_grades)
    print(f"სტუდენტი {i}: საშუალო = {average:.2f}")

# თითოეული გამოცდის საშუალო ქულა
for exam in range(3):
    exam_total = sum(grades[student][exam] for student in range(3))
    average = exam_total / 3
    print(f"გამოცდა {exam + 1}: საშუალო = {average:.2f}")
9. Tuple მონაცემთა ტიპი
9.1 Tuple-ის შექმნა
python# Tuple შექმნა ფრჩხილებით
coordinates = (10, 20)
print(coordinates)  # (10, 20)

# Tuple ფრჩხილების გარეშე
point = 5, 15
print(point)  # (5, 15)

# ერთელემენტიანი tuple (მძიმე აუცილებელია!)
single = (42,)
print(type(single))  # <class 'tuple'>

wrong = (42)
print(type(wrong))   # <class 'int'> - ეს tuple არ არის!

# ცარიელი tuple
empty = ()
print(empty)  # ()
9.2 Tuple-ის თვისებები
python# Tuple არის immutable (შეუცვლელი)
coordinates = (10, 20, 30)
print(coordinates[0])  # 10 - წაკითხვა შეიძლება

# coordinates[0] = 100  # TypeError - ცვლილება შეუძლებელია!

# Tuple-ის unpacking
x, y, z = coordinates
print(f"x={x}, y={y}, z={z}")  # x=10, y=20, z=30

# მნიშვნელობების გაცვლა
a = 5
b = 10
a, b = b, a
print(f"a={a}, b={b}")  # a=10, b=5
9.3 Tuple vs List - როდის რა გამოვიყენოთ
python# List - როცა მონაცემები იცვლება
shopping_list = ["რძე", "პური", "კვერცხი"]
shopping_list.append("კარაქი")  # OK

# Tuple - როცა მონაცემები უნდა დარჩეს უცვლელი
coordinates = (40.7128, -74.0060)  # ნიუ იორკის კოორდინატები
# coordinates[0] = 0  # შეცდომა - არ უნდა შეიცვალოს!

# Tuple როგორც dictionary-ის key
locations = {
    (40.7128, -74.0060): "ნიუ იორკი",
    (51.5074, -0.1278): "ლონდონი"
}
print(locations[(40.7128, -74.0060)])  # ნიუ იორკი
9.4 Tuple-ის მეთოდები
pythonnumbers = (1, 2, 3, 2, 4, 2, 5)

# count() - ელემენტის რაოდენობა
print(numbers.count(2))  # 3

# index() - ელემენტის ინდექსი
print(numbers.index(4))  # 4

# len() - სიგრძე
print(len(numbers))  # 7

# min() და max()
print(min(numbers))  # 1
print(max(numbers))  # 5
10. List Comprehension (სიის გენერაცია)
10.1 ძირითადი სინტაქსი
python# ტრადიციული გზა
squares = []
for x in range(1, 11):
    squares.append(x ** 2)
print(squares)  # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# List comprehension
squares = [x ** 2 for x in range(1, 11)]
print(squares)  # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
10.2 პირობით List Comprehension
python# მხოლოდ ლუწი რიცხვები
evens = [x for x in range(20) if x % 2 == 0]
print(evens)  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

# დადებითი რიცხვების კვადრატები
numbers = [-5, -2, 0, 3, 7, -1, 9]
positive_squares = [x ** 2 for x in numbers if x > 0]
print(positive_squares)  # [9, 49, 81]

# სტრიქონების ფილტრაცია
words = ["ვაშლი", "მსხალი", "კივი", "ბანანი", "ატამი"]
long_words = [word for word in words if len(word) > 4]
print(long_words)  # ['მსხალი', 'ბანანი', 'ატამი']



პრაქტიკული ამოცანები
ამოცანა 1: საშუალო ქულის გამოთვლა
შექმენით პროგრამა, რომელიც:

მიიღებს 5 სტუდენტის ქულებს
გამოთვლის თითოეული სტუდენტის საშუალო ქულას
დაბეჭდავს მაქსიმალურ და მინიმალურ ქულებს

ამოცანა 2: სიის ფილტრაცია
მოცემული რიცხვების სიიდან:

ამოშალეთ ყველა უარყოფითი რიცხვი
დაალაგეთ დარჩენილი რიცხვები კლებადობით
დაბეჭდეთ შედეგი

ამოცანა 3: სიტყვების სია
შექმენით პროგრამა, რომელიც:

მიიღებს მომხმარებლისგან სიტყვებს (შეწყვეტა: "stop")
შეინახავს მათ სიაში
დაალაგებს ანბანის მიხედვით
დაბეჭდავს თითოეული სიტყვის სიგრძეს

ამოცანა 4: დუბლიკატების მოძებნა
დაწერეთ ფუნქცია, რომელიც:

მიიღებს რიცხვების სიას
იპოვის ყველა დუბლიკატს
დააბრუნებს დუბლიკატების სიას (თითოეული ერთხელ)

ამოცანა 5: მატრიცის ტრანსპონირება
შექმენით ფუნქცია, რომელიც:

მიიღებს 3x3 მატრიცას
შექმნის ტრანსპონირებულ მატრიცას (რიგები და სვეტები გადაიცვლება)
დააბრუნებს ახალ მატრიცას

ამოცანა 6: ლოტოს რიცხვები
შექმენით პროგრამა, რომელიც:

შექმნის 6 შემთხვევითი რიცხვის სიას (1-დან 49-მდე)
დაალაგებს მათ ზრდადობით
შეამოწმებს დუბლიკატების არსებობას
თუ არის დუბლიკატი, ხელახლა გენერირდება რიცხვები

ამოცანა 7: სტუდენტების რეიტინგი
შექმენით პროგრამა, რომელიც:

შეინახავს სტუდენტების სახელებსა და ქულებს tuple-ების სიაში
დაალაგებს სტუდენტებს ქულების მიხედვით (კლებადობით)
დაბეჭდავს რეიტინგს (ადგილი, სახელი, ქულა)

ამოცანა 8: სიების გაერთიანება
დაწერეთ ფუნქცია, რომელიც:

მიიღებს ორ დალაგებულ სიას
გააერთიანებს მათ ერთ დალაგებულ სიაში
არ გამოიყენოს sort() ან sorted() ფუნქციები


!!! warning რჩევები და საუკეთესო პრაქტიკა

გამოიყენეთ სწორი სახელები: items, numbers, students - აშკარა და აღწერილობითი
List vs Tuple: გამოიყენეთ tuple უცვლელი მონაცემებისთვის
List Comprehension: მარტივი ოპერაციებისთვის უფრო კომპაქტურია
Slicing: ეფექტური გზა სიების ნაწილების მისაღებად
copy(): ყოველთვის გამოიყენეთ სიის დამოუკიდებელი ასლის შესაქმნელად
in ოპერატორი: სწრაფი გზა ელემენტის არსებობის შესამოწმებლად
