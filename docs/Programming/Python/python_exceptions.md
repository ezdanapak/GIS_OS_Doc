# შეცდომები (Exceptions) Python-ში

## შესავალი
შეცდომა (*exception*) არის არასაკმარისი/არელაჩვეული მდგომარეობა, რომელიც ჩნდება პროგრამის შესრულებისას და წყვეტს ნორმალურ მიმდინარეობას.  
Exception-ების მართვა გვაძლევს საშუალებას პროგრამა **არ ავარდეს**, არამედ **კონტროლირებულად** იმოქმედოს.

---

## შეცდომების ძირითადი ტიპები
ზოგადი, ხშირად შემხვედრი შეცდომები:
- `SyntaxError` – სინტაქსის შეცდომა (კომპილაციის/პარსინგის ეტაპზე)
- `NameError` – ცვლადი/სახელი არ არსებობს
- `TypeError` – ტიპები შეუთავსებელია
- `ValueError` – მნიშვნელობა არასწორია (ტიპი სწორი, მნიშვნელობა არა)
- `IndexError` – ინდექსი ფარგლებს გარეთაა
- `KeyError` – გასაღები არ არსებობს ლექსიკონში
- `ZeroDivisionError` – ნულზე გაყოფა
- `FileNotFoundError` – ფაილი ვერ მოიძებნა
- `IOError`/`OSError` – შესატან/გამოტან ოპერაციებზე პრობლემები

```python
# მაგალითი: ZeroDivisionError
x = 10
y = 0
# print(x / y)  # გამოიწვევს შეცდომას
```

---

## try–except
ძირითადი კონსტრუქცია შეცდომის დასაჭერად:

```python
try:
    risky = int(input("შეიყვანე მთელი რიცხვი: "))
    print(100 / risky)
except ValueError:
    print("შეყვანილი მნიშვნელობა არ არის მთელი რიცხვი.")
except ZeroDivisionError:
    print("ნულზე გაყოფა დაუშვებელია.")
```

### მრავალი ტიპის ერთთან დაჭერა
```python
try:
    ...
except (ValueError, TypeError) as e:
    print("ვერ обработდა:", e)
```

---

## try–except–else–finally
- `else`: შესრულდება მაშინ, როცა **არ** მოხდა uitzondering
- `finally`: შესრულდება **ყოველთვის** (მნიშვნელოვანია რესურსების დახურვისთვის)

```python
try:
    n = int(input("რიცხვი: "))
    res = 100 / n
except (ValueError, ZeroDivisionError) as e:
    print("შეცდომა:", e)
else:
    print("წარმატება! შედეგი =", res)
finally:
    print("ეს ბლოკი ყოველთვის სრულდება (ლოღირების/რესურსების დახურვა).")
```

---

## შეცდომის მიზანმიმართული აგდება (`raise`)
```python
def get_even(x):
    if x % 2 != 0:
        raise ValueError("მნიშვნელობა უნდა იყოს ლუწი.")
    return x

# get_even(3)  # გამოაგდებს ValueError-ს
```

---

## `with … as` — კონტექსტ მენეჯერი
`with` უზრუნველყოფს რესურსის ავტომატურ დახურვას/გაწმენდას (ფაილები, ქსელი, lock-ები).

```python
# ფაილის უსაფრთხო კითხვა
try:
    with open("data.txt", "r", encoding="utf-8") as f:
        for line in f:
            print(line.strip())
except FileNotFoundError:
    print("ფაილი ვერ მოიძებნა.")
```

კონტექსტ მენეჯერი გარანტირებულად ახურავს ფაილს, თუნდაც შუაში მოხდეს შეცდომა.

---

## საკუთარი Exception კლასები
შეგიძლია განასაზღვრო დომენ-სპეციფიკური შეცდომა:

```python
class InvalidGradeError(Exception):
    """ანიშნულის არასწორი დიაპაზონი."""

def set_grade(value):
    if not (0 <= value <= 100):
        raise InvalidGradeError("ქულა უნდა იყოს 0–100 დიაპაზონში.")
    return value
```

---

## კარგი პრაქტიკები
- დაიჭირე **კონკრეტული** შეცდომები; დიდი `except Exception:` მხოლოდ ზედა დონეზე გამოიყენე ლოღირებისთვის.
- `finally` გამოიყენე რესურსების დახურვისთვის.
- ტექსტური შეტყობინებები გააკეთე **მომხმარებლისთვის გასაგებად**.
- არ ჩააფარო ბაგები `bare except`-ით — პრობლემის დიანოსტიკა დაგიჭირდება.

---

## ანტიპატერნები (რას მოვერიდოთ)
```python
try:
    dangerous()
except Exception:
    pass   # ❌ ჩუმად ვყლაპავთ ყველა შეცდომას — ცუდი პრაქტიკაა
```

---

## [1] პრაქტიკული დავალებები #1–#3

### დავალება #1 — უსაფრთხო გაყოფა
დაწერე ფუნქცია `safe_div(a, b)`, რომელიც აბრუნებს `a/b`-ს.  
თუ `b == 0`, დააბრუნე `"ნულზე გაყოფა დაუშვებელია"`.
```python
def safe_div(a, b):
    try:
        return a / b
    except ZeroDivisionError:
        return "ნულზე გაყოფა დაუშვებელია"

print(safe_div(10, 2))  # 5.0
print(safe_div(10, 0))  # შეტყობინება
```

### დავალება #2 — უსაფრთხო გარდაქმნა
წაიკითხე მომხმარებლის შეყვანა და აქციე `int`-ად.  
თუ ვერ გარდაიქმნება, შეატყობინე და სთხოვე თავიდან.
```python
def read_int(prompt="რიცხვი: "):
    while True:
        try:
            return int(input(prompt))
        except ValueError:
            print("გთხოვ, შეიყვანე მთელი რიცხვი. სცადე კიდევ.")

n = read_int()
print("მიღებულია:", n)
```

### დავალება #3 — ფაილი და with–as
კონტექსტ მენეჯერის გამოყენებით წაიკითხე ფაილი, რომლის სახელსაც მომხმარებელი შეიყვანს.  
თუ ფაილი არ არსებობს — მოახდინე კორექტული ინფორმირება და არ დააგდი პროგრამა.
```python
def read_file_interactive():
    name = input("ფაილის სახელი: ")
    try:
        with open(name, "r", encoding="utf-8") as f:
            print("--- ფაილის შინაარსი ---")
            print(f.read())
    except FileNotFoundError:
        print("ფაილი ვერ მოიძებნა:", name)

read_file_interactive()
```

---

## განხილვა–ანალიზი
- `try–except–else–finally` საშუალებას გვაძლევს **განვაცალკევოთ** წარმატებული მიმდინარეობა, შეცდომების დამუშავება და რესურსების გაწმენდა.
- `with–as` ამცირებს გაჟონვის რისკს (ფაილი/ქსელი/lock), აუმჯობესებს კოდის სისუფთავეს.
- საკუთარი Exception კლასები ხელს უწყობს დომენურ ლოგიკაში მკაფიო ერორ-მენეჯმენტს.
- პრაქტიკული დავალებები აჩვენებს: **პროგრამა არ უნდა ავარდეს** მოსალოდნელი შეცდომების გამო — სჯობს წინასწარ განჭვრეტა და კორექტული რეაქცია.

**საყოფაცხოვრებო რჩევა:** ლაბებში ჩართეთ „ხარვეზების ინიაციას“ — შეგნებულად შექმენით შეცდომები (ცარიელი შეყვანა, არარსებული ფაილი, ნულზე გაყოფა) და დააკვირდით, სწორად იჭერთ თუ არა.
